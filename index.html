<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Labyrinth</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Orbitron:wght@400;700&family=Roboto:wght@400;700&display=swap');
        
        :root {
            --cell-size: 28px;
            --maze-size: 15;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            overflow: hidden;
            font-family: 'Roboto', sans-serif;
            background-color: #000;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            height: 100vh;
            width: 100vw;
        }
        
        .title {
            font-family: 'Creepster', cursive;
            text-shadow: 2px 2px 8px rgba(255, 0, 0, 0.6);
        }
        
        .game-font {
            font-family: 'Orbitron', sans-serif;
        }
        
        .home-screen {
            background-image: radial-gradient(circle at center, #1a1a2e 0%, #16213e 50%, #0f0f0f 100%);
            height: 100vh;
            width: 100vw;
            position: absolute;
            z-index: 100;
            transition: opacity 1s ease-in-out;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: #0a0a0a;
            display: none;
        }
        
        .maze {
            position: relative;
            margin: auto;
            transition: transform 0.5s ease-out;
        }
        
        .cell {
            position: absolute;
            transition: background-color 0.3s ease;
        }
        
        .wall {
            background-color: #333;
            border: 1px solid #444;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .path {
            background-color: #111;
            border: 1px solid #222;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
        }
        
        .fog {
            background-color: #000;
            position: absolute;
            z-index: 2;
            transition: opacity 0.5s ease;
        }
        
        .player {
            position: absolute;
            z-index: 5;
            transition: all 0.2s ease;
            filter: drop-shadow(0 0 10px rgba(0, 200, 255, 0.8));
        }
        
        .monster {
            position: absolute;
            z-index: 4;
            transition: all 0.3s ease;
            filter: drop-shadow(0 0 10px rgba(255, 0, 0, 0.8));
        }
        
        .trap {
            position: absolute;
            z-index: 3;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,87,34,0.7) 0%, rgba(0,0,0,0) 70%);
            animation: pulse-trap 3s infinite;
        }
        
        .exit {
            position: absolute;
            z-index: 3;
            background: radial-gradient(circle, rgba(0,255,0,0.7) 0%, rgba(0,0,0,0) 70%);
            border-radius: 50%;
            animation: pulse-exit 2s infinite;
        }
        
        .powerup {
            position: absolute;
            z-index: 3;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,215,0,0.7) 0%, rgba(0,0,0,0) 70%);
            animation: pulse-powerup 2s infinite;
        }
        
        .game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            z-index: 10;
            pointer-events: none;
        }
        
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .directional-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            width: 150px;
            height: 150px;
        }
        
        .control-btn {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            user-select: none;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 10px rgba(0, 200, 255, 0.3);
            transition: all 0.2s ease;
        }
        
        .control-btn:active {
            background-color: rgba(0, 200, 255, 0.4);
            transform: scale(0.95);
        }
        
        #upBtn {
            grid-column: 2;
            grid-row: 1;
        }
        
        #leftBtn {
            grid-column: 1;
            grid-row: 2;
        }
        
        #rightBtn {
            grid-column: 3;
            grid-row: 2;
        }
        
        #downBtn {
            grid-column: 2;
            grid-row: 3;
        }
        
        .game-over, .level-complete, .pause-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 20;
            display: none;
            backdrop-filter: blur(5px);
        }
        
        .btn {
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            border: none;
            outline: none;
            font-family: 'Orbitron', sans-serif;
        }
        
        .btn:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: 0.5s;
        }
        
        .btn:hover:before {
            left: 100%;
        }
        
        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(0, 200, 255, 0.7);
        }
        
        .btn:active {
            transform: scale(0.95);
        }
        
        .progress-container {
            width: 100%;
            height: 8px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #00ccff;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .mini-map {
            position: absolute;
            bottom: 120px;
            right: 15px;
            width: 120px;
            height: 120px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #333;
            border-radius: 5px;
            z-index: 10;
            overflow: hidden;
            display: none;
        }
        
        .mini-map-content {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        .mini-map-cell {
            position: absolute;
        }
        
        .mini-map-wall {
            background-color: #555;
        }
        
        .mini-map-path {
            background-color: #222;
        }
        
        .mini-map-player {
            background-color: #00ccff;
            border-radius: 50%;
            z-index: 2;
        }
        
        .mini-map-monster {
            background-color: #ff3333;
            border-radius: 50%;
            z-index: 1;
        }
        
        .mini-map-exit {
            background-color: #00ff00;
            border-radius: 50%;
            z-index: 1;
        }
        
        .notification {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 16px;
            z-index: 15;
            opacity: 0;
            transition: opacity 0.3s ease;
            text-align: center;
            max-width: 90%;
        }
        
        @keyframes pulse-trap {
            0% { opacity: 0.3; }
            50% { opacity: 0.8; }
            100% { opacity: 0.3; }
        }
        
        @keyframes pulse-exit {
            0% { opacity: 0.5; transform: scale(0.9); }
            50% { opacity: 1; transform: scale(1.1); }
            100% { opacity: 0.5; transform: scale(0.9); }
        }
        
        @keyframes pulse-powerup {
            0% { opacity: 0.5; transform: scale(0.9) rotate(0deg); }
            50% { opacity: 1; transform: scale(1.1) rotate(180deg); }
            100% { opacity: 0.5; transform: scale(0.9) rotate(360deg); }
        }
        
        @keyframes shake {
            0% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(-5px, -5px) rotate(-5deg); }
            50% { transform: translate(5px, 5px) rotate(5deg); }
            75% { transform: translate(-5px, 5px) rotate(-5deg); }
            100% { transform: translate(0, 0) rotate(0deg); }
        }
        
        .shake {
            animation: shake 0.5s;
        }
        
        .flash {
            animation: flash 0.5s;
        }
        
        @keyframes flash {
            0% { background-color: rgba(255, 0, 0, 0); }
            50% { background-color: rgba(255, 0, 0, 0.3); }
            100% { background-color: rgba(255, 0, 0, 0); }
        }
        
        /* Mobile enhancements */
        .mobile-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.7);
            border-bottom: 1px solid #333;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 11;
        }
        
        .mobile-stats {
            display: flex;
            gap: 15px;
        }
        
        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 5px 10px;
            text-align: center;
        }
        
        .stat-label {
            font-size: 12px;
            color: #aaa;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
        }
        
        .action-btn {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 18px;
            pointer-events: auto;
        }
        
        /* Desktop controls */
        .desktop-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            z-index: 10;
            text-align: center;
            display: none;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            :root {
                --cell-size: 24px;
            }
            
            .mini-map {
                width: 100px;
                height: 100px;
                bottom: 140px;
            }
            
            .directional-controls {
                width: 140px;
                height: 140px;
            }
            
            .control-btn {
                width: 45px;
                height: 45px;
                font-size: 20px;
            }
            
            .desktop-controls {
                display: none;
            }
        }
        
        @media (min-width: 769px) {
            .controls {
                display: none;
            }
            
            .desktop-controls {
                display: block;
            }
        }
        
        @media (max-width: 480px) {
            :root {
                --cell-size: 20px;
            }
            
            .mobile-stats {
                gap: 8px;
            }
            
            .stat-box {
                padding: 4px 8px;
            }
            
            .stat-value {
                font-size: 16px;
            }
            
            .directional-controls {
                width: 130px;
                height: 130px;
            }
            
            .control-btn {
                width: 40px;
                height: 40px;
            }
            
            .home-screen h1 {
                font-size: 2.5rem;
            }
        }
        
        @media (max-height: 700px) {
            :root {
                --cell-size: 20px;
            }
            
            .controls {
                bottom: 10px;
            }
            
            .mini-map {
                bottom: 110px;
            }
        }
        
        @media (max-height: 600px) {
            :root {
                --cell-size: 18px;
            }
            
            .controls {
                bottom: 5px;
            }
            
            .mini-map {
                bottom: 100px;
                width: 90px;
                height: 90px;
            }
        }
        
        /* Home screen particles */
        .particle {
            position: absolute;
            border-radius: 50%;
        }
    </style>
</head>
<body class="bg-black text-white">
    <!-- Home Screen -->
    <div id="homeScreen" class="home-screen">
        <div class="absolute top-0 left-0 w-full h-full overflow-hidden z-0" id="particleContainer"></div>
        
        <h1 class="title text-4xl md:text-6xl mb-6 text-red-500 z-10">Labyrinth</h1>
        <div class="w-48 h-48 md:w-56 md:h-56 relative mb-6 z-10">
            <svg class="w-full h-full" viewBox="0 0 100 100">
                <rect x="0" y="0" width="100" height="100" fill="#0f0f0f" />
                <path d="M10,10 L90,10 L90,90 L10,90 Z" fill="none" stroke="#444" stroke-width="2" />
                <path d="M20,10 L20,30 L40,30 L40,20 L60,20 L60,40 L50,40 L50,60 L70,60 L70,80 L90,80" fill="none" stroke="#444" stroke-width="2" />
                <path d="M10,20 L30,20 L30,40 L10,40" fill="none" stroke="#444" stroke-width="2" />
                <path d="M10,50 L30,50 L30,70 L50,70 L50,90" fill="none" stroke="#444" stroke-width="2" />
                <path d="M40,40 L40,50 L20,50" fill="none" stroke="#444" stroke-width="2" />
                <path d="M60,50 L80,50 L80,30 L70,30 L70,10" fill="none" stroke="#444" stroke-width="2" />
                <path d="M60,60 L60,80 L40,80 L40,90" fill="none" stroke="#444" stroke-width="2" />
                <path d="M80,60 L90,60" fill="none" stroke="#444" stroke-width="2" />
                <path d="M10,80 L30,80" fill="none" stroke="#444" stroke-width="2" />
                
                <circle id="homeCharacter" cx="15" cy="15" r="5" fill="#00ccff">
                    <animate attributeName="opacity" values="0.7;1;0.7" dur="2s" repeatCount="indefinite" />
                </circle>
                
                <circle id="homeMonster" cx="85" cy="85" r="5" fill="#ff3333">
                    <animate attributeName="opacity" values="0.7;1;0.7" dur="2s" repeatCount="indefinite" />
                </circle>
            </svg>
        </div>
        <div class="flex flex-col items-center z-10 w-full max-w-md">
            <button id="startBtn" class="btn bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-8 rounded-full text-xl mb-4 w-48">
                START GAME
            </button>
            <button id="howToPlayBtn" class="btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-full text-lg mb-4 w-40">
                HOW TO PLAY
            </button>
            <div class="text-center px-4">
                <p class="mb-2 text-gray-300">Navigate through endless mazes while avoiding traps and a relentless monster.</p>
                <p class="text-sm text-gray-400">Use arrow keys or on-screen controls to move</p>
            </div>
        </div>
    </div>

    <!-- How To Play Screen -->
    <div id="howToPlayScreen" class="home-screen flex flex-col items-center justify-center" style="display: none;">
        <h1 class="title text-3xl md:text-4xl mb-6 text-red-500">How To Play</h1>
        <div class="bg-gray-900 bg-opacity-70 p-5 rounded-lg max-w-md mx-4">
            <ul class="list-disc pl-5 space-y-3 text-sm md:text-base">
                <li><span class="text-blue-400">Goal:</span> Find the exit (green glow) to advance to the next floor.</li>
                <li><span class="text-red-400">Danger:</span> Avoid the monster that will chase you when you're visible.</li>
                <li><span class="text-orange-400">Traps:</span> Red glowing areas will alert the monster to your location.</li>
                <li><span class="text-yellow-400">Power-ups:</span> Collect gold items for temporary speed boosts or invisibility.</li>
                <li><span class="text-green-400">Fog of War:</span> You can only see a small area around you.</li>
                <li><span class="text-purple-400">Difficulty:</span> Each floor gets progressively harder with faster monsters and more traps.</li>
            </ul>
            <div class="mt-6 flex justify-center">
                <div class="grid grid-cols-2 gap-3">
                    <div class="flex items-center">
                        <div class="w-6 h-6 bg-blue-500 rounded-full mr-2"></div>
                        <span>Player</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-6 h-6 bg-red-500 rounded-full mr-2"></div>
                        <span>Monster</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-6 h-6 bg-green-500 rounded-full mr-2"></div>
                        <span>Exit</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-6 h-6 bg-orange-500 rounded-full mr-2"></div>
                        <span>Trap</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-6 h-6 bg-yellow-500 rounded-full mr-2"></div>
                        <span>Power-up</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-6 h-6 bg-gray-800 rounded-full mr-2"></div>
                        <span>Fog</span>
                    </div>
                </div>
            </div>
        </div>
        <button id="backBtn" class="btn bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded-full text-lg mt-6">
            BACK
        </button>
    </div>

    <!-- Game Container -->
    <div id="gameContainer" class="game-container">
        <!-- Mobile Header -->
        <div class="mobile-header">
            <div class="mobile-stats">
                <div class="stat-box">
                    <div class="stat-label">FLOOR</div>
                    <div id="floorLevel" class="stat-value">1</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">SCORE</div>
                    <div id="scoreValue" class="stat-value">0</div>
                </div>
            </div>
            <div class="action-buttons">
                <div id="mapBtn" class="action-btn">
                    <i class="fas fa-map"></i>
                </div>
                <div id="pauseBtn" class="action-btn">
                    <i class="fas fa-pause"></i>
                </div>
            </div>
        </div>
        
        <div id="maze" class="maze"></div>
        
        <!-- Power-up indicator -->
        <div id="powerupIndicator" class="fixed top-16 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-70 px-4 py-2 rounded-full hidden">
            <div class="flex items-center">
                <div id="powerupIcon" class="w-6 h-6 mr-2 rounded-full bg-yellow-500"></div>
                <span id="powerupName" class="mr-2 game-font">Speed Boost</span>
                <div class="progress-container w-24">
                    <div id="powerupProgress" class="progress-bar" style="width: 100%"></div>
                </div>
            </div>
        </div>
        
        <!-- Mini-map -->
        <div id="miniMap" class="mini-map">
            <div id="miniMapContent" class="mini-map-content"></div>
        </div>
        
        <!-- Notification -->
        <div id="notification" class="notification"></div>
        
        <!-- Mobile Controls -->
        <div class="controls">
            <div class="directional-controls">
                <div class="control-btn" id="upBtn">
                    <i class="fas fa-arrow-up"></i>
                </div>
                <div class="control-btn" id="leftBtn">
                    <i class="fas fa-arrow-left"></i>
                </div>
                <div class="control-btn" id="rightBtn">
                    <i class="fas fa-arrow-right"></i>
                </div>
                <div class="control-btn" id="downBtn">
                    <i class="fas fa-arrow-down"></i>
                </div>
            </div>
        </div>
        
        <!-- Desktop Controls -->
        <div class="desktop-controls">
            <p>Use arrow keys to move</p>
            <p>Press M for map | P to pause</p>
        </div>
        
        <!-- Game Over Screen -->
        <div id="gameOver" class="game-over">
            <h2 class="title text-4xl text-red-500 mb-4">GAME OVER</h2>
            <p class="mb-2">You reached floor <span id="finalFloor">1</span></p>
            <p class="mb-6">Final score: <span id="finalScore">0</span></p>
            <button id="restartBtn" class="btn bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-8 rounded-full mb-4">
                TRY AGAIN
            </button>
            <button id="menuBtn" class="btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-full">
                MAIN MENU
            </button>
        </div>
        
        <!-- Level Complete Screen -->
        <div id="levelComplete" class="level-complete">
            <h2 class="title text-4xl text-green-500 mb-4">FLOOR CLEARED!</h2>
            <p class="mb-2">Descending to floor <span id="nextFloor">2</span></p>
            <p class="mb-6">Current score: <span id="currentScore">0</span></p>
            <div class="w-16 h-16 relative">
                <svg class="animate-spin" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" fill="none"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
            </div>
        </div>
        
        <!-- Pause Screen -->
        <div id="pauseScreen" class="pause-screen">
            <h2 class="title text-4xl text-blue-500 mb-6">GAME PAUSED</h2>
            <button id="resumeBtn" class="btn bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-full mb-4">
                RESUME
            </button>
            <button id="restartFromPauseBtn" class="btn bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-6 rounded-full mb-4">
                RESTART
            </button>
            <button id="quitBtn" class="btn bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-full">
                QUIT
            </button>
        </div>
    </div>

    <script>
        // Game state
        const state = {
            gameStarted: false,
            paused: false,
            currentFloor: 1,
            score: 0,
            mazeSize: 15,
            cellSize: 0,
            playerPosition: { x: 1, y: 1 },
            monsterPosition: { x: 0, y: 0 },
            monsterActive: false,
            traps: [],
            powerups: [],
            maze: [],
            fogOfWar: [],
            visibilityRadius: 2,
            playerElement: null,
            monsterElement: null,
            exitPosition: { x: 0, y: 0 },
            gameOver: false,
            keysPressed: {},
            lastUpdate: 0,
            monsterSpeed: 0.7,
            monsterUpdateCounter: 0,
            miniMapVisible: false,
            activePowerup: null,
            powerupTimer: 0,
            powerupDuration: 10000,
            particles: []
        };

        // DOM Elements
        const homeScreen = document.getElementById('homeScreen');
        const howToPlayScreen = document.getElementById('howToPlayScreen');
        const gameContainer = document.getElementById('gameContainer');
        const mazeElement = document.getElementById('maze');
        const floorLevelElement = document.getElementById('floorLevel');
        const scoreValueElement = document.getElementById('scoreValue');
        const gameOverScreen = document.getElementById('gameOver');
        const levelCompleteScreen = document.getElementById('levelComplete');
        const pauseScreen = document.getElementById('pauseScreen');
        const finalFloorElement = document.getElementById('finalFloor');
        const finalScoreElement = document.getElementById('finalScore');
        const nextFloorElement = document.getElementById('nextFloor');
        const currentScoreElement = document.getElementById('currentScore');
        const miniMap = document.getElementById('miniMap');
        const miniMapContent = document.getElementById('miniMapContent');
        const powerupIndicator = document.getElementById('powerupIndicator');
        const powerupName = document.getElementById('powerupName');
        const powerupProgress = document.getElementById('powerupProgress');
        const notification = document.getElementById('notification');
        const particleContainer = document.getElementById('particleContainer');

        // Create particles for home screen
        function createParticles() {
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.classList.add('particle');
                const size = Math.random() * 3 + 1;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                particle.style.backgroundColor = `rgba(${Math.floor(Math.random() * 100 + 100)}, ${Math.floor(Math.random() * 100 + 100)}, ${Math.floor(Math.random() * 255)}, ${Math.random() * 0.5 + 0.3})`;
                
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                
                const speed = Math.random() * 1 + 0.5;
                const angle = Math.random() * Math.PI * 2;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                
                state.particles.push({
                    element: particle,
                    x,
                    y,
                    vx,
                    vy
                });
                
                particleContainer.appendChild(particle);
            }
        }

        // Animate particles
        function animateParticles() {
            for (const particle of state.particles) {
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // Wrap around screen
                if (particle.x < 0) particle.x = window.innerWidth;
                if (particle.x > window.innerWidth) particle.x = 0;
                if (particle.y < 0) particle.y = window.innerHeight;
                if (particle.y > window.innerHeight) particle.y = 0;
                
                particle.element.style.left = `${particle.x}px`;
                particle.element.style.top = `${particle.y}px`;
            }
            
            if (!state.gameStarted) {
                requestAnimationFrame(animateParticles);
            }
        }

        // Show notification
        function showNotification(message, duration = 3000) {
            notification.textContent = message;
            notification.style.opacity = 1;
            
            setTimeout(() => {
                notification.style.opacity = 0;
            }, duration);
        }

        // Initialize the game
        function initGame() {
            state.cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'));
            state.playerSpeed = 1;
            resetGame();
            
            // Event listeners for mobile controls
            document.getElementById('upBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                state.keysPressed.ArrowUp = true;
            });
            document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                state.keysPressed.ArrowLeft = true;
            });
            document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                state.keysPressed.ArrowRight = true;
            });
            document.getElementById('downBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                state.keysPressed.ArrowDown = true;
            });
            
            document.getElementById('upBtn').addEventListener('touchend', (e) => {
                e.preventDefault();
                state.keysPressed.ArrowUp = false;
            });
            document.getElementById('leftBtn').addEventListener('touchend', (e) => {
                e.preventDefault();
                state.keysPressed.ArrowLeft = false;
            });
            document.getElementById('rightBtn').addEventListener('touchend', (e) => {
                e.preventDefault();
                state.keysPressed.ArrowRight = false;
            });
            document.getElementById('downBtn').addEventListener('touchend', (e) => {
                e.preventDefault();
                state.keysPressed.ArrowDown = false;
            });
            
            // Map button
            document.getElementById('mapBtn').addEventListener('click', toggleMiniMap);
            
            // Keyboard events
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            
            // Start game loop
            requestAnimationFrame(gameLoop);
        }

        // Toggle mini-map
        function toggleMiniMap() {
            state.miniMapVisible = !state.miniMapVisible;
            miniMap.style.display = state.miniMapVisible ? 'block' : 'none';
            updateMiniMap();
        }

        // Update mini-map
        function updateMiniMap() {
            if (!state.miniMapVisible) return;
            
            miniMapContent.innerHTML = '';
            const cellSize = Math.min(miniMap.offsetWidth, miniMap.offsetHeight) / state.mazeSize;
            
            // Draw maze
            for (let y = 0; y < state.mazeSize; y++) {
                for (let x = 0; x < state.mazeSize; x++) {
                    // Only show cells that have been revealed
                    if (!state.fogOfWar[y][x]) {
                        const cell = document.createElement('div');
                        cell.className = `mini-map-cell ${state.maze[y][x] === 1 ? 'mini-map-wall' : 'mini-map-path'}`;
                        cell.style.width = `${cellSize}px`;
                        cell.style.height = `${cellSize}px`;
                        cell.style.left = `${x * cellSize}px`;
                        cell.style.top = `${y * cellSize}px`;
                        miniMapContent.appendChild(cell);
                    }
                }
            }
            
            // Draw exit if visible
            if (!state.fogOfWar[state.exitPosition.y][state.exitPosition.x]) {
                const exit = document.createElement('div');
                exit.className = 'mini-map-cell mini-map-exit';
                exit.style.width = `${cellSize}px`;
                exit.style.height = `${cellSize}px`;
                exit.style.left = `${state.exitPosition.x * cellSize}px`;
                exit.style.top = `${state.exitPosition.y * cellSize}px`;
                miniMapContent.appendChild(exit);
            }
            
            // Draw player
            const player = document.createElement('div');
            player.className = 'mini-map-cell mini-map-player';
            player.style.width = `${cellSize}px`;
            player.style.height = `${cellSize}px`;
            player.style.left = `${state.playerPosition.x * cellSize}px`;
            player.style.top = `${state.playerPosition.y * cellSize}px`;
            miniMapContent.appendChild(player);
            
            // Draw monster if visible
            if (!state.fogOfWar[state.monsterPosition.y][state.monsterPosition.x]) {
                const monster = document.createElement('div');
                monster.className = 'mini-map-cell mini-map-monster';
                monster.style.width = `${cellSize}px`;
                monster.style.height = `${cellSize}px`;
                monster.style.left = `${state.monsterPosition.x * cellSize}px`;
                monster.style.top = `${state.monsterPosition.y * cellSize}px`;
                miniMapContent.appendChild(monster);
            }
        }

        // Reset game state for a new game or level
        function resetGame(nextFloor = false) {
            if (!nextFloor) {
                state.currentFloor = 1;
                state.monsterSpeed = 0.7;
                state.score = 0;
                state.gameOver = false;
            } else {
                state.currentFloor++;
                state.monsterSpeed = Math.min(0.7 + state.currentFloor * 0.03, 0.95);
                // Add score for completing a floor
                state.score += state.currentFloor * 100;
            }
            
            // Update UI
            floorLevelElement.textContent = state.currentFloor;
            scoreValueElement.textContent = state.score;
            
            // Clear active powerup
            if (state.activePowerup) {
                state.activePowerup.end();
                state.activePowerup = null;
                powerupIndicator.classList.add('hidden');
            }
            
            // Generate new maze with size based on floor
            state.mazeSize = Math.min(15 + Math.floor(state.currentFloor / 3), 25);
            state.cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'));
            generateMaze();
            
            // Place player at start
            state.playerPosition = { x: 1, y: 1 };
            
            // Place monster far from player
            placeMonster();
            
            // Place exit
            placeExit();
            
            // Place traps
            placeTraps();
            
            // Place powerups
            placePowerups();
            
            // Initialize fog of war
            initFogOfWar();
            
            // Render maze
            renderMaze();
            
            // Update mini-map if visible
            if (state.miniMapVisible) {
                updateMiniMap();
            }
            
            // Start monster after delay
            state.monsterActive = false;
            setTimeout(() => {
                state.monsterActive = true;
                showNotification("The monster is now active!", 2000);
            }, 3000);
        }

        // Generate maze using recursive backtracking
        function generateMaze() {
            const size = state.mazeSize;
            state.maze = Array(size).fill().map(() => Array(size).fill(1));
            
            // Start with all walls
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    state.maze[y][x] = 1;
                }
            }
            
            // Carve paths
            carvePassagesFrom(1, 1);
            
            // Ensure start and end are open
            state.maze[1][1] = 0;
            state.maze[size - 2][size - 2] = 0;
            
            // Add some random paths to make maze less linear
            const extraPaths = Math.floor(size * size * 0.05);
            for (let i = 0; i < extraPaths; i++) {
                const x = Math.floor(Math.random() * (size - 2)) + 1;
                const y = Math.floor(Math.random() * (size - 2)) + 1;
                if (state.maze[y][x] === 1) {
                    // Check if it would create a 2x2 open area (avoid this)
                    let adjacentOpenCount = 0;
                    if (x > 0 && state.maze[y][x-1] === 0) adjacentOpenCount++;
                    if (x < size-1 && state.maze[y][x+1] === 0) adjacentOpenCount++;
                    if (y > 0 && state.maze[y-1][x] === 0) adjacentOpenCount++;
                    if (y < size-1 && state.maze[y+1][x] === 0) adjacentOpenCount++;
                    
                    if (adjacentOpenCount <= 2) {
                        state.maze[y][x] = 0;
                    }
                }
            }
        }

        // Recursive backtracking algorithm to generate maze
        function carvePassagesFrom(x, y) {
            const directions = [
                [0, -2], // North
                [2, 0],  // East
                [0, 2],  // South
                [-2, 0]  // West
            ];
            
            // Shuffle directions
            directions.sort(() => Math.random() - 0.5);
            
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx > 0 && nx < state.mazeSize - 1 && ny > 0 && ny < state.mazeSize - 1 && state.maze[ny][nx] === 1) {
                    // Carve passage
                    state.maze[y + dy/2][x + dx/2] = 0;
                    state.maze[ny][nx] = 0;
                    carvePassagesFrom(nx, ny);
                }
            }
        }

        // Place monster far from player
        function placeMonster() {
            const size = state.mazeSize;
            let placed = false;
            
            while (!placed) {
                const x = Math.floor(Math.random() * (size - 2)) + 1;
                const y = Math.floor(Math.random() * (size - 2)) + 1;
                
                // Check if it's a valid path and far from player
                if (state.maze[y][x] === 0) {
                    const distance = Math.abs(x - state.playerPosition.x) + Math.abs(y - state.playerPosition.y);
                    if (distance > size / 2) {
                        state.monsterPosition = { x, y };
                        placed = true;
                    }
                }
            }
        }

        // Place exit
        function placeExit() {
            const size = state.mazeSize;
            // Try to place exit far from start
            let bestDistance = 0;
            let bestPosition = { x: size - 2, y: size - 2 };
            
            for (let y = 1; y < size - 1; y++) {
                for (let x = 1; x < size - 1; x++) {
                    if (state.maze[y][x] === 0) {
                        const distance = Math.abs(x - 1) + Math.abs(y - 1);
                        if (distance > bestDistance) {
                            bestDistance = distance;
                            bestPosition = { x, y };
                        }
                    }
                }
            }
            
            state.exitPosition = bestPosition;
        }

        // Place traps
        function placeTraps() {
            const size = state.mazeSize;
            const numTraps = Math.floor(size * size * 0.05) + Math.floor(state.currentFloor / 2);
            state.traps = [];
            
            for (let i = 0; i < numTraps; i++) {
                let placed = false;
                
                while (!placed) {
                    const x = Math.floor(Math.random() * (size - 2)) + 1;
                    const y = Math.floor(Math.random() * (size - 2)) + 1;
                    
                    // Check if it's a valid path and not player, monster, or exit
                    if (state.maze[y][x] === 0 && 
                        !(x === state.playerPosition.x && y === state.playerPosition.y) &&
                        !(x === state.monsterPosition.x && y === state.monsterPosition.y) &&
                        !(x === state.exitPosition.x && y === state.exitPosition.y) &&
                        !state.traps.some(trap => trap.x === x && trap.y === y)) {
                        
                        state.traps.push({ x, y });
                        placed = true;
                    }
                }
            }
        }

        // Place powerups
        function placePowerups() {
            const size = state.mazeSize;
            const numPowerups = Math.min(2 + Math.floor(state.currentFloor / 3), 5);
            state.powerups = [];
            
            for (let i = 0; i < numPowerups; i++) {
                let placed = false;
                
                while (!placed) {
                    const x = Math.floor(Math.random() * (size - 2)) + 1;
                    const y = Math.floor(Math.random() * (size - 2)) + 1;
                    
                    // Check if it's a valid path and not player, monster, exit, trap, or another powerup
                    if (state.maze[y][x] === 0 && 
                        !(x === state.playerPosition.x && y === state.playerPosition.y) &&
                        !(x === state.monsterPosition.x && y === state.monsterPosition.y) &&
                        !(x === state.exitPosition.x && y === state.exitPosition.y) &&
                        !state.traps.some(trap => trap.x === x && trap.y === y) &&
                        !state.powerups.some(powerup => powerup.x === x && powerup.y === y)) {
                        
                        // Random powerup type
                        const type = {
                            name: "Speed Boost",
                            color: "#ffd700",
                            effect: () => {
                                state.playerSpeed = 2;
                                showNotification("Speed Boost activated!");
                            },
                            end: () => {
                                state.playerSpeed = 1;
                            }
                        };
                        state.powerups.push({ x, y, type });
                        placed = true;
                    }
                }
            }
        }

        // Initialize fog of war
        function initFogOfWar() {
            const size = state.mazeSize;
            state.fogOfWar = Array(size).fill().map(() => Array(size).fill(true));
            updateFogOfWar();
        }

        // Update fog of war based on player position
        function updateFogOfWar() {
            const { x, y } = state.playerPosition;
            const radius = state.visibilityRadius;
            
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < state.mazeSize && ny >= 0 && ny < state.mazeSize) {
                        // Check if cell is within visibility radius (using Manhattan distance)
                        if (Math.abs(dx) + Math.abs(dy) <= radius) {
                            state.fogOfWar[ny][nx] = false;
                        }
                    }
                }
            }
        }

        // Render the maze
        function renderMaze() {
            mazeElement.innerHTML = '';
            const mazeSizePx = state.mazeSize * state.cellSize;
            mazeElement.style.width = `${mazeSizePx}px`;
            mazeElement.style.height = `${mazeSizePx}px`;
            
            // Center the maze
            const offsetX = (window.innerWidth - mazeSizePx) / 2;
            const offsetY = (window.innerHeight - mazeSizePx) / 2;
            //mazeElement.style.left = `${offsetX}px`;
            mazeElement.style.top = `${offsetY}px`;
            
            // Render cells
            for (let y = 0; y < state.mazeSize; y++) {
                for (let x = 0; x < state.mazeSize; x++) {
                    const cell = document.createElement('div');
                    cell.className = state.maze[y][x] === 1 ? 'cell wall' : 'cell path';
                    cell.style.width = `${state.cellSize}px`;
                    cell.style.height = `${state.cellSize}px`;
                    cell.style.left = `${x * state.cellSize}px`;
                    cell.style.top = `${y * state.cellSize}px`;
                    mazeElement.appendChild(cell);
                    
                    // Add fog of war
                    if (state.fogOfWar[y][x]) {
                        const fog = document.createElement('div');
                        fog.className = 'fog';
                        fog.style.width = `${state.cellSize}px`;
                        fog.style.height = `${state.cellSize}px`;
                        fog.style.left = `${x * state.cellSize}px`;
                        fog.style.top = `${y * state.cellSize}px`;
                        mazeElement.appendChild(fog);
                    }
                }
            }
            
            // Render exit
            const exit = document.createElement('div');
            exit.className = 'exit';
            exit.style.width = `${state.cellSize}px`;
            exit.style.height = `${state.cellSize}px`;
            exit.style.left = `${state.exitPosition.x * state.cellSize}px`;
            exit.style.top = `${state.exitPosition.y * state.cellSize}px`;
            mazeElement.appendChild(exit);
            
            // Render traps
            state.traps.forEach(trap => {
                const trapElement = document.createElement('div');
                trapElement.className = 'trap';
                trapElement.style.width = `${state.cellSize}px`;
                trapElement.style.height = `${state.cellSize}px`;
                trapElement.style.left = `${trap.x * state.cellSize}px`;
                trapElement.style.top = `${trap.y * state.cellSize}px`;
                mazeElement.appendChild(trapElement);
            });
            
            // Render powerups
            state.powerups.forEach(powerup => {
                const powerupElement = document.createElement('div');
                powerupElement.className = 'powerup';
                powerupElement.style.width = `${state.cellSize}px`;
                powerupElement.style.height = `${state.cellSize}px`;
                powerupElement.style.left = `${powerup.x * state.cellSize}px`;
                powerupElement.style.top = `${powerup.y * state.cellSize}px`;
                powerupElement.style.background = `radial-gradient(circle, ${powerup.type.color} 0%, rgba(0,0,0,0) 70%)`;
                mazeElement.appendChild(powerupElement);
            });
            
            // Render player
            const player = document.createElement('div');
            player.className = 'player';
            player.style.width = `${state.cellSize}px`;
            player.style.height = `${state.cellSize}px`;
            player.style.left = `${state.playerPosition.x * state.cellSize}px`;
            player.style.top = `${state.playerPosition.y * state.cellSize}px`;
            player.innerHTML = `
                <svg viewBox="0 0 50 50" width="100%" height="100%">
                    <circle cx="25" cy="25" r="22" fill="#00ccff" opacity="0.7">
                        <animate attributeName="r" values="22;20;22" dur="2s" repeatCount="indefinite" />
                    </circle>
                    <circle cx="25" cy="25" r="15" fill="#00eeff" opacity="0.9" />
                </svg>
            `;
            mazeElement.appendChild(player);
            state.playerElement = player;
            
            // Render monster
            const monster = document.createElement('div');
            monster.className = 'monster';
            monster.style.width = `${state.cellSize}px`;
            monster.style.height = `${state.cellSize}px`;
            monster.style.left = `${state.monsterPosition.x * state.cellSize}px`;
            monster.style.top = `${state.monsterPosition.y * state.cellSize}px`;
            monster.innerHTML = `
                <svg viewBox="0 0 50 50" width="100%" height="100%">
                    <circle cx="25" cy="25" r="22" fill="#ff3333" opacity="0.7">
                        <animate attributeName="r" values="22;20;22" dur="1.5s" repeatCount="indefinite" />
                    </circle>
                    <circle cx="25" cy="25" r="15" fill="#ff0000" opacity="0.9" />
                </svg>
            `;
            mazeElement.appendChild(monster);
            state.monsterElement = monster;
        }

        // Update player position
        function updatePlayerPosition(dx, dy) {
            if (state.gameOver || state.paused) return;
            
            const newX = state.playerPosition.x + dx;
            const newY = state.playerPosition.y + dy;
            
            // Check if new position is valid
            if (newX >= 0 && newX < state.mazeSize && newY >= 0 && newY < state.mazeSize && state.maze[newY][newX] === 0) {
                state.playerPosition.x = newX;
                state.playerPosition.y = newY;
                
                // Update player element position
                state.playerElement.style.left = `${newX * state.cellSize}px`;
                state.playerElement.style.top = `${newY * state.cellSize}px`;
                
                // Update fog of war
                updateFogOfWar();
                
                // Check for collisions
                checkCollisions();
                
                // Update mini-map if visible
                if (state.miniMapVisible) {
                    updateMiniMap();
                }
            }
        }

        // Update monster position
        function updateMonsterPosition() {
            if (!state.monsterActive || state.gameOver || state.paused) return;
            
            // Simple pathfinding towards player
            const dx = state.playerPosition.x - state.monsterPosition.x;
            const dy = state.playerPosition.y - state.monsterPosition.y;
            
            let moveX = 0;
            let moveY = 0;
            
            // Prioritize the direction with the largest difference
            if (Math.abs(dx) > Math.abs(dy)) {
                moveX = dx > 0 ? 1 : -1;
            } else {
                moveY = dy > 0 ? 1 : -1;
            }
            
            // Check if the move is valid
            const newX = state.monsterPosition.x + moveX;
            const newY = state.monsterPosition.y + moveY;
            
            if (newX >= 0 && newX < state.mazeSize && newY >= 0 && newY < state.mazeSize && state.maze[newY][newX] === 0) {
                state.monsterPosition.x = newX;
                state.monsterPosition.y = newY;
                
                // Update monster element position
                state.monsterElement.style.left = `${newX * state.cellSize}px`;
                state.monsterElement.style.top = `${newY * state.cellSize}px`;
                
                // Check for collisions
                checkCollisions();
                
                // Update mini-map if visible
                if (state.miniMapVisible) {
                    updateMiniMap();
                }
            }
        }

        // Check for collisions
        function checkCollisions() {
            const { x, y } = state.playerPosition;
            
            // Check for monster collision
            if (x === state.monsterPosition.x && y === state.monsterPosition.y) {
                gameOver();
                return;
            }
            
            // Check for trap collision
            const trapIndex = state.traps.findIndex(trap => trap.x === x && trap.y === y);
            if (trapIndex !== -1) {
                // Shake the screen
                gameContainer.classList.add('shake');
                setTimeout(() => {
                    gameContainer.classList.remove('shake');
                }, 500);
                
                // Monster gets closer
                state.monsterActive = true;
                showNotification("Trap triggered! The monster knows your location!", 2000);
                
                // Remove the trap
                state.traps.splice(trapIndex, 1);
                renderMaze();
                
                // Add score
                state.score += 10;
                scoreValueElement.textContent = state.score;
            }
            
            // Check for powerup collision
            const powerupIndex = state.powerups.findIndex(powerup => powerup.x === x && powerup.y === y);
            if (powerupIndex !== -1) {
                const powerup = state.powerups[powerupIndex];
                
                // Apply powerup effect
                if (state.activePowerup) {
                    state.activePowerup.end();
                }
                
                state.activePowerup = powerup.type;
                state.activePowerup.effect();
                state.powerupTimer = state.powerupDuration;
                
                // Update UI
                powerupName.textContent = powerup.type.name;
                powerupIndicator.classList.remove('hidden');
                document.getElementById('powerupIcon').style.backgroundColor = powerup.type.color;
                
                // Remove the powerup
                state.powerups.splice(powerupIndex, 1);
                renderMaze();
                
                // Add score
                state.score += 25;
                scoreValueElement.textContent = state.score;
            }
            
            // Check for exit collision
            if (x === state.exitPosition.x && y === state.exitPosition.y) {
                levelComplete();
            }
        }

        // Game over
        function gameOver() {
            state.gameOver = true;
            finalFloorElement.textContent = state.currentFloor;
            finalScoreElement.textContent = state.score;
            gameOverScreen.style.display = 'flex';
            
            // Flash the screen red
            gameContainer.classList.add('flash');
            setTimeout(() => {
                gameContainer.classList.remove('flash');
            }, 500);
        }

        // Level complete
        function levelComplete() {
            nextFloorElement.textContent = state.currentFloor + 1;
            currentScoreElement.textContent = state.score;
            levelCompleteScreen.style.display = 'flex';
            
            setTimeout(() => {
                levelCompleteScreen.style.display = 'none';
                resetGame(true);
            }, 2000);
        }

        // Handle key down
        function handleKeyDown(e) {
            if (state.paused) return;
            
            state.keysPressed[e.key] = true;
            
            // Toggle mini-map with 'M' key
            if (e.key === 'm' || e.key === 'M') {
                toggleMiniMap();
            }
            
            // Pause with 'P' key or Escape
            if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') {
                togglePause();
            }
        }

        // Handle key up
        function handleKeyUp(e) {
            state.keysPressed[e.key] = false;
        }

        // Toggle pause
        function togglePause() {
            state.paused = !state.paused;
            pauseScreen.style.display = state.paused ? 'flex' : 'none';
        }

        // Update powerup timer
        function updatePowerupTimer(deltaTime) {
            if (state.activePowerup) {
                state.powerupTimer -= deltaTime;
                
                // Update progress bar
                const progress = Math.max(0, state.powerupTimer / state.powerupDuration * 100);
                powerupProgress.style.width = `${progress}%`;
                
                // End powerup if timer expired
                if (state.powerupTimer <= 0) {
                    state.activePowerup.end();
                    state.activePowerup = null;
                    powerupIndicator.classList.add('hidden');
                }
            }
        }

        // Game loop
        function gameLoop(timestamp) {
            // Calculate delta time
            const deltaTime = state.lastUpdate ? timestamp - state.lastUpdate : 0;
            state.lastUpdate = timestamp;
            
            if (!state.paused && !state.gameOver) {
                // Update powerup timer
                updatePowerupTimer(deltaTime);
                
                // Update player position based on keys pressed
                if (deltaTime > 0) {
                    const moveInterval = 150 / (state.playerSpeed || 1); // ms between moves
                    
                    if (!state.lastMoveTime || timestamp - state.lastMoveTime > moveInterval) {
                        if (state.keysPressed.ArrowUp) {
                            updatePlayerPosition(0, -1);
                            state.lastMoveTime = timestamp;
                        } else if (state.keysPressed.ArrowDown) {
                            updatePlayerPosition(0, 1);
                            state.lastMoveTime = timestamp;
                        } else if (state.keysPressed.ArrowLeft) {
                            updatePlayerPosition(-1, 0);
                            state.lastMoveTime = timestamp;
                        } else if (state.keysPressed.ArrowRight) {
                            updatePlayerPosition(1, 0);
                            state.lastMoveTime = timestamp;
                        }
                    }
                    
                    // Update monster position less frequently
                    state.monsterUpdateCounter += deltaTime;
                    if (state.monsterUpdateCounter > moveInterval / state.monsterSpeed) {
                        updateMonsterPosition();
                        state.monsterUpdateCounter = 0;
                    }
                    
                    // Update fog of war rendering
                    const fogElements = document.querySelectorAll('.fog');
                    for (let i = 0; i < fogElements.length; i++) {
                        const element = fogElements[i];
                        const y = Math.floor(i / state.mazeSize);
                        const x = i % state.mazeSize;
                        element.style.display = state.fogOfWar[y][x] ? 'block' : 'none';
                    }
                }
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            homeScreen.style.opacity = 0;
            setTimeout(() => {
                homeScreen.style.display = 'none';
                gameContainer.style.display = 'block';
                state.gameStarted = true;
                state.lastMoveTime = 0;
                initGame();
            }, 1000);
        });

        document.getElementById('howToPlayBtn').addEventListener('click', () => {
            homeScreen.style.display = 'none';
            howToPlayScreen.style.display = 'flex';
        });

        document.getElementById('backBtn').addEventListener('click', () => {
            howToPlayScreen.style.display = 'none';
            homeScreen.style.display = 'flex';
        });

        document.getElementById('restartBtn').addEventListener('click', () => {
            gameOverScreen.style.display = 'none';
            resetGame();
        });

        document.getElementById('menuBtn').addEventListener('click', () => {
            gameOverScreen.style.display = 'none';
            gameContainer.style.display = 'none';
            homeScreen.style.display = 'flex';
            homeScreen.style.opacity = 1;
            state.gameStarted = false;
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            togglePause();
        });

        document.getElementById('resumeBtn').addEventListener('click', () => {
            togglePause();
        });

        document.getElementById('restartFromPauseBtn').addEventListener('click', () => {
            pauseScreen.style.display = 'none';
            state.paused = false;
            resetGame();
        });

        document.getElementById('quitBtn').addEventListener('click', () => {
            pauseScreen.style.display = 'none';
            gameContainer.style.display = 'none';
            homeScreen.style.display = 'flex';
            homeScreen.style.opacity = 1;
            state.gameStarted = false;
            state.paused = false;
        });

        // Create particles and start animations
        createParticles();
        animateParticles();
    </script>
</body>
</html>
